{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"13523416881673635887","abi":{"parameters":[{"name":"clave","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"path","type":{"kind":"array","length":11,"type":{"kind":"field"}},"visibility":"private"},{"name":"path_indices","type":{"kind":"array","length":11,"type":{"kind":"field"}},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9WciXNTVRTGT5IWyqIitLJWBRWkKtybpUmqQqkKUhWkKkhVaCMpUhWkKghuuO8r/y/DOXDfcOfxYN7wzvfm3jtzJm8SOPm+s/TXJUmFbp6rHHN0+6m420l32zDjzWa/Xe/bhp039W6v0zLNVm+8Yzu21WmdqncajX6n2Wl3e9226dpmo28XWt3Ggrl5Nnu5TMGD1Lnl3nXW03eItrUcAymt19x1xbve7F1vcdfJ/xvleJjjEY5HvftRNdh67zWweWpwJ9/+9dZUDbZxPMbxOMcTGTWoKtdgI6nNq92ml8ukZ+luc2CKHXufom5f73ak4O2AvDsUBwvle4dXYKW8mVqL+q86rdp5vwH7NsWOHQX5/pYwYB1Q9l9V9Pykoi7FubGx9GJUsRc7QTsc0l5kfRMjM5h8s7KT8n0jN8bxFMfTHM+4+8sE+v2EAfoupOBdgLy7KWygi+/dXoGV8kKAXnNatfNeAfs2xY4dA/n+juKASE3Rs1HUdUUxVyy9GFPshQXtcEh7kQV0aVACbkv5gF4XXxxNjhaVD/QHCAP0caTgcUDeNoUNdPHd9gqslBcC9AGnVTvv92DfptixdZDvHygOiAwoeu4o6lKcGxtLL+qKveiCdjikvcgCusxgAu4u5QP6BMezHM9xPE/lA30NYYC+Byl4DyDvXgob6OJ7r1dgpbwQoA86rdp5fwT7NsWOnQD5/onigMigoudJRV2Kc2Nj6cWEYi/2gXY4pL3IArrkTsC9j/IBfYrjBY4XOV6i8oH+IGGAvh8peD8g7wEKG+ji+4BXYKW8EKAvc1q18/4M9m2KHTsF8v0LxQGRZYqeX1bUpTg3NpZeTCn24iBoh0Paiyygywwm4D5I+YA+zfEKx6scr1H5QF9LGKAfQgo+BMh7mMIGuvg+7BVYKS8E6MudVu28v4J9m2LHToN8/0ZxQGS5oufXFXUpzo2NpRfTir04AtrhkPYiC+gygwm4j1A+oM9wvMHxJsdbVD7Q1xEG6EeRgo8C8h6jsIEuvo95BVbKCwH6kNOqnfd3sG9T7NgZkO8/KA6IDCl6fltRl+Lc2Fh6MaPYi+OgHQ5pL7KALjOYgPs45QP6LMc7HO9yvEflA32YMEA/gRR8ApD3JIUNdPF90iuwUl4I0Fc4rdp5/wT7NsWOnQX5/ovigMgKRc9ziroU58bG0otZxV7Mg3Y4pL3IAvoc3QL3POUDeo/jfY5THH0qH+gjhAH6AlLwAiDvaQob6OL7tFdgpbwQoK90WrXz/g32bYod2wP5/ofigMhKRc8fKOpSnBsbSy96ir04A9rhkPYiC+gygwm4z1A+oC9yfMjxEcfHVD7QHyIM0M8iBZ8F5D1HYQNdfJ/zCqyUFwL0VU6rdt5/wb5NsWMXQb7/ozggskrR8yeKuhTnxsbSi0XFXpwH7XBIe5EFdJnBBNznKR/Qlzg+5fiM43MqH+jrCQP0C0jBFwB5L1LYQBffF70CK+WFAH2106qd93+wb1Ps2CWQ76sUB0RWK3r+QlGX4tzYWHqxpNiLS6AdDmkvsoAuM5iA+xLlA/plji85vuL4mvAfd7tBcWYug2Y7ZM+blGco6fcGz3/F1aDmHpe398o7guRFxPK6I/lTpfx2U34gkq+h8qmw8kFy8tkzazjkHW4ym/I6OvnTu/y2Xn7AX+/VVp5vI91iz6bU85N7Hv92xHu8pljTJP8wJv+NF92nz4h3PZzyWfUem1TSkOSrudtBuv1UU48l/3Yopa+ir8+mtdQynis569ztsHdfUs/ryywzUW9eAAA=","debug_symbols":"pZfRauswDIbfJde9sGRLsvcqh8PIumwEQlqydnAYe/fjNr/XbuAwkpv+TRx91S9LJv1onrun8+tjP74c3pqHPx/N09QPQ//6OBz27ak/jPnux+euKZePp6nr8q3mbj1HHdupG0/Nw3gehl3z3g7n60Nvx3a86qmd8qrbNd34nDUDX/qhu3z73N2iXT1UJCBYnf8Kl+/xVI/3wogPpLd4+xbP9XjmmABg77hG8HUCkZYUiKKsycFISw7mXY0gCzmY+ZKDpaoLrRNSEACSxBXx5PirCk5ljYfkyk5Q4qqHhV4yLkWw+wx+9JLb2Ey00I2sscwCa/JVxEIzkL+VwXN1K8hv3MvFOqT4VQdZVYffdTTp5pYm29yTi1lsb0ortYyUak25EJ/MymbGsCKe3M2B41UEUrsdcG4Nwd82wqvWCBy2nvOy+aBn3X7Sy+bB4Lh5MDhtPCCWAL+crEUbmyeLgi+jReHeR+6qv/mq3ffTt9edxuUh3DV0/eTrp8+xWcIsklPOP6iXFtk1NkucJeUezCceOShBGeqhYX6cBAoYGdYjFDwGj8Fjnp9nDwWPBesKBY/BY/C8m5/3BAXPIz8foOB58Dx4HnZ9mjWAF5BfgN8AXgAvgBfgN6B6AbyA/AR+BTwBT8AT+BXUT8AT5CfwK+ApeAqewq+ifgqeIj+FXwVPwVPwDH4N9TPwDPkZ/Bp4Bp6BZ/BrqF8ELyK/CL8RvAheBC/CbyzdB15Efgl+E3gJvAReuvAuLx7v7dS3T0OH9/yX87i/e+0//TuWlfLH4Dgd9t3zeeouM3Ndy1P0Hw==","file_map":{"50":{"source":"use poseidon::poseidon2;\n\nglobal DEPTH: u32 = 11;\n\nfn main(\n    // Entradas privadas\n    clave: Field,\n    nullifier: Field,\n    path: [Field; DEPTH],         // Camino de hermanos desde hoja hasta raiz\n    path_indices: [Field; DEPTH], // 0 = izquierda, 1 = derecha para cada nivel\n\n    // Entradas publicas\n    root: pub Field,              // Raiz del arbol Merkle\n    nullifier_hash: pub Field     // Hash del nullifier para evitar doble gasto\n) -> pub Field {\n    // 1. Calcular la hoja a partir de clave + nullifier usando Poseidon2\n    let leaf = poseidon2::Poseidon2::hash([clave, nullifier], 2);\n\n    // 2. Verificar que el nullifier_hash publico corresponde al nullifier privado\n    let computed_nullifier_hash = poseidon2::Poseidon2::hash([nullifier], 1);\n    assert(computed_nullifier_hash == nullifier_hash);\n    \n    // 3. Verificar el camino Merkle desde la hoja hasta la raiz\n    let mut current_hash = leaf;\n\n    for i in 0..DEPTH {\n        let path_element = path[i];\n        let is_right = path_indices[i];\n\n        // Si is_right == 0, current_hash va a la izquierda\n        // Si is_right == 1, current_hash va a la derecha\n        let left = if is_right == 0 { current_hash } else { path_element };\n        let right = if is_right == 0 { path_element } else { current_hash };\n\n        current_hash = poseidon2::Poseidon2::hash([left, right], 2);\n    }\n\n    // 4. Verificar que llegamos a la raiz esperada\n    assert(current_hash == root);\n    current_hash\n    \n}\n\n#[test]\nfn test_merkle_proof() {\n    let clave = 123;\n    let nullifier = 456;\n    let nullifier_hash = poseidon2::Poseidon2::hash([nullifier], 1);\n\n    let path: [Field; 11] = [0; 11];\n    let path_indices: [Field; 11] = [0; 11];\n\n    // Calcula la hoja\n    let leaf = poseidon2::Poseidon2::hash([clave, nullifier], 2);\n    let mut current_hash = leaf;\n    for i in 0..11 {\n        let path_element = path[i];\n        let is_right = path_indices[i];\n        let left = if is_right == 0 { current_hash } else { path_element };\n        let right = if is_right == 0 { path_element } else { current_hash };\n        current_hash = poseidon2::Poseidon2::hash([left, right], 2);\n    }\n    let root = current_hash;\n\n    let result = main(clave, nullifier, path, path_indices, root, nullifier_hash);\n    assert(result == root);\n}\n","path":"/home/ram/Workspace/Voting/vanilla_v0.1/backend/noir/merkle11/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/ram/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_invert"]}